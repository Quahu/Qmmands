using System;
using System.Collections.Generic;
using Qommon;
using Qommon.Collections;
using Qommon.Collections.ThreadSafe;

namespace Qmmands;

public partial class DefaultCommandRateLimiter
{
    /// <summary>
    ///     Represents a node of the <see cref="DefaultCommandRateLimiter"/>,
    ///     i.e. a store of rate-limit buckets for the given rate-limit information.
    /// </summary>
    public class Node
    {
        /// <summary>
        ///     Gets the rate-limiter of this node.
        /// </summary>
        public DefaultCommandRateLimiter RateLimiter { get; }

        /// <summary>
        ///     Gets the rate-limit information of this node.
        /// </summary>
        public IReadOnlyList<RateLimitAttribute> RateLimits { get; }

        /// <summary>
        ///     Gets the buckets of this node keyed by the keys generated by <see cref="DefaultCommandRateLimiter.BucketKeyGenerator"/>.
        /// </summary>
        public IThreadSafeDictionary<object, Bucket> Buckets { get; }

        /// <summary>
        ///     Instantiates a new <see cref="Node"/> with the rate-limiter and rate-limit information.
        /// </summary>
        /// <param name="rateLimiter"> The rate-limiter. </param>
        /// <param name="rateLimits"> The rate-limit information. </param>
        public Node(DefaultCommandRateLimiter rateLimiter, IEnumerable<RateLimitAttribute> rateLimits)
        {
            RateLimiter = rateLimiter;
            RateLimits = rateLimits.GetArray();
            Buckets = ThreadSafeDictionary.ConcurrentDictionary.Create<object, Bucket>();
        }

        /// <summary>
        ///     Executes rate-limiting code for this node.
        /// </summary>
        /// <param name="context"> The command context. </param>
        /// <returns>
        ///     An <see cref="IResult"/>.
        /// </returns>
        public virtual IResult RateLimit(ICommandContext context)
        {
            ClearExpiredBuckets();

            var rateLimits = RateLimits;
            var rateLimitCount = rateLimits.Count;
            var buckets = new Bucket?[rateLimitCount];
            for (var i = 0; i < rateLimitCount; i++)
            {
                var rateLimit = rateLimits[i];
                var bucket = GetBucket(context, rateLimit);
                buckets[i] = bucket;
            }

            Dictionary<RateLimitAttribute, TimeSpan>? rateLimitedBuckets = null;
            foreach (var bucket in buckets)
            {
                if (bucket != null && bucket.IsRateLimited(out var retryAfter))
                    (rateLimitedBuckets ??= new(buckets.Length)).Add(bucket.RateLimit, retryAfter);
            }

            if (rateLimitedBuckets != null && rateLimitedBuckets.Count > 0)
                return new CommandRateLimitedResult(rateLimitedBuckets);

            foreach (var bucket in buckets)
                bucket?.Decrement();

            return Results.Success;
        }

        /// <summary>
        ///     Clears expired buckets.
        /// </summary>
        protected virtual void ClearExpiredBuckets()
        {
            var now = DateTimeOffset.UtcNow;
            var buckets = Buckets.ToArray();
            foreach (var bucket in buckets)
            {
                if (now > bucket.Value.LastCall + bucket.Value.RateLimit.Window)
                    Buckets.TryRemove(bucket.Key, out _);
            }
        }

        /// <summary>
        ///     Gets a bucket for the given context and rate-limit information.
        /// </summary>
        /// <param name="context"> The command context. </param>
        /// <param name="rateLimit"> The rate-limit information. </param>
        /// <returns>
        ///     A <see cref="Bucket"/> or <see langword="null"/> to skip rate-limiting.
        /// </returns>
        protected virtual Bucket? GetBucket(ICommandContext context, RateLimitAttribute rateLimit)
        {
            Guard.IsNotNull(RateLimiter.BucketKeyGenerator);

            var key = RateLimiter.BucketKeyGenerator(context, rateLimit.BucketType);
            return key == null ? null : Buckets.GetOrAdd(key, _ => RateLimiter.CreateBucket(rateLimit));
        }
    }
}
